<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>X√°c ƒê·ªãnh Ph∆∞·ªùng/X√£ Ch√≠nh X√°c</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body {
            font-family: 'Arial', sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 10px;
        }
        .description {
            text-align: center;
            margin-bottom: 20px;
            color: #7f8c8d;
        }
        #locate-btn {
            display: block;
            width: 250px;
            margin: 0 auto 30px;
            padding: 12px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        #locate-btn:hover {
            background-color: #2980b9;
        }
        #locate-btn.loading {
            background-color: #95a5a6;
            cursor: wait;
        }
        #result-container {
            min-height: 150px;
            margin-bottom: 30px;
        }
        .location-card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        .location-title {
            font-size: 18px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }
        .location-title svg {
            margin-right: 10px;
        }
        .address-detail {
            margin-bottom: 8px;
            padding-left: 28px;
        }
        .detail-label {
            font-weight: bold;
            color: #3498db;
            display: inline-block;
            width: 100px;
        }
        .warning {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 12px;
            margin-top: 15px;
            border-radius: 4px;
            color: #856404;
        }
        #map {
            height: 500px;
            width: 100%;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            margin-top: 20px;
            z-index: 1;
        }
        .accuracy-circle {
            stroke: #3498db;
            stroke-width: 2;
            fill: #3498db;
            fill-opacity: 0.2;
        }
        .legend {
            padding: 10px;
            background: white;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            line-height: 1.5;
        }
        .legend i {
            width: 18px;
            height: 18px;
            float: left;
            margin-right: 8px;
            opacity: 0.7;
        }
        .map-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
        }
        .map-control-btn {
            background: white;
            border: none;
            padding: 8px 12px;
            margin-left: 5px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>X√°c ƒê·ªãnh Ph∆∞·ªùng/X√£ Ch√≠nh X√°c</h1>
    <p class="description">Ch∆∞∆°ng tr√¨nh gi√∫p x√°c ƒë·ªãnh ch√≠nh x√°c v·ªã tr√≠ c·ªßa b·∫°n thu·ªôc ph∆∞·ªùng/x√£ n√†o</p>
    
    <button id="locate-btn">
        <span id="btn-text">X√°c ƒë·ªãnh v·ªã tr√≠ c·ªßa t√¥i</span>
        <span id="btn-spinner" style="display:none;">ƒêang x·ª≠ l√Ω...</span>
    </button>
    
    <div id="result-container">
        <div class="location-card">
            <div class="location-title">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#3498db" stroke-width="2">
                    <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                    <circle cx="12" cy="10" r="3"></circle>
                </svg>
                K·∫øt qu·∫£ s·∫Ω hi·ªÉn th·ªã t·∫°i ƒë√¢y
            </div>
            <p style="text-align: center; color: #95a5a6;">Nh·∫•n n√∫t "X√°c ƒë·ªãnh v·ªã tr√≠ c·ªßa t√¥i" ƒë·ªÉ b·∫Øt ƒë·∫ßu</p>
        </div>
    </div>

    <div id="map"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Kh·ªüi t·∫°o b·∫£n ƒë·ªì
        const map = L.map('map').setView([10.762622, 106.660172], 8);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        // Bi·∫øn to√†n c·ª•c
        let marker = null;
        let accuracyCircle = null;
        let adminBoundary = null;
        let currentPosition = null;

        // C√°c l·ªõp ranh gi·ªõi h√†nh ch√≠nh
        const boundaryStyles = {
            'ward': { color: '#e74c3c', fillColor: '#e74c3c', weight: 3, opacity: 1, fillOpacity: 0.2 },
            'district': { color: '#9b59b6', fillColor: '#9b59b6', weight: 3, opacity: 1, fillOpacity: 0.2 },
            'province': { color: '#3498db', fillColor: '#3498db', weight: 3, opacity: 1, fillOpacity: 0.2 }
        };

        // X·ª≠ l√Ω s·ª± ki·ªán click n√∫t
        document.getElementById('locate-btn').addEventListener('click', locateUser);

        async function locateUser() {
            const btn = document.getElementById('locate-btn');
            const btnText = document.getElementById('btn-text');
            const btnSpinner = document.getElementById('btn-spinner');
            
            // Hi·ªÉn th·ªã tr·∫°ng th√°i loading
            btn.classList.add('loading');
            btnText.style.display = 'none';
            btnSpinner.style.display = 'inline';
            
            // Hi·ªÉn th·ªã th√¥ng b√°o ch·ªù
            showResultMessage('ƒêang x√°c ƒë·ªãnh v·ªã tr√≠ c·ªßa b·∫°n...', 'info');
            
            try {
                // L·∫•y v·ªã tr√≠ hi·ªán t·∫°i
                const position = await getCurrentPosition();
                currentPosition = position;
                
                // Hi·ªÉn th·ªã tr√™n b·∫£n ƒë·ªì
                updateMap(position.coords.latitude, position.coords.longitude, position.coords.accuracy);
                
                // L·∫•y th√¥ng tin ƒë·ªãa ch·ªâ
                const address = await getEnhancedAddressInfo(
                    position.coords.latitude, 
                    position.coords.longitude
                );
                
                // Hi·ªÉn th·ªã k·∫øt qu·∫£
                displayAddressInfo(address);
                
                // Th·ª≠ l·∫•y ranh gi·ªõi h√†nh ch√≠nh
                await fetchAdministrativeBoundary(
                    position.coords.latitude, 
                    position.coords.longitude,
                    address
                );
                
            } catch (error) {
                console.error('L·ªói:', error);
                showResultMessage(`L·ªói: ${error.message}`, 'error');
            } finally {
                // Kh√¥i ph·ª•c tr·∫°ng th√°i n√∫t
                btn.classList.remove('loading');
                btnText.style.display = 'inline';
                btnSpinner.style.display = 'none';
            }
        }

        function getCurrentPosition() {
            return new Promise((resolve, reject) => {
                if (!navigator.geolocation) {
                    reject(new Error('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ ƒë·ªãnh v·ªã ƒë·ªãa l√Ω'));
                }
                
                navigator.geolocation.getCurrentPosition(
                    position => resolve(position),
                    error => {
                        let message;
                        switch(error.code) {
                            case error.PERMISSION_DENIED:
                                message = "B·∫°n ƒë√£ t·ª´ ch·ªëi y√™u c·∫ßu ƒë·ªãnh v·ªã";
                                break;
                            case error.POSITION_UNAVAILABLE:
                                message = "Th√¥ng tin v·ªã tr√≠ kh√¥ng kh·∫£ d·ª•ng";
                                break;
                            case error.TIMEOUT:
                                message = "Y√™u c·∫ßu ƒë·ªãnh v·ªã h·∫øt th·ªùi gian ch·ªù";
                                break;
                            default:
                                message = "L·ªói kh√¥ng x√°c ƒë·ªãnh khi l·∫•y v·ªã tr√≠";
                        }
                        reject(new Error(message));
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 15000,
                        maximumAge: 0
                    }
                );
            });
        }

        function updateMap(lat, lng, accuracy) {
            // Di chuy·ªÉn b·∫£n ƒë·ªì ƒë·∫øn v·ªã tr√≠ m·ªõi
            map.setView([lat, lng], 14);
            
            // X√≥a marker c≈© n·∫øu c√≥
            if (marker) {
                map.removeLayer(marker);
            }
            
            // Th√™m marker m·ªõi
            marker = L.marker([lat, lng], {
                icon: L.divIcon({
                    className: 'custom-marker',
                    html: '<svg width="30" height="30" viewBox="0 0 24 24" fill="#e74c3c" stroke="#fff" stroke-width="2"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>',
                    iconSize: [30, 30],
                    iconAnchor: [15, 30]
                })
            }).addTo(map)
            .bindPopup("V·ªã tr√≠ c·ªßa b·∫°n").openPopup();
            
            // X√≥a v√≤ng ƒë·ªô ch√≠nh x√°c c≈© n·∫øu c√≥
            if (accuracyCircle) {
                map.removeLayer(accuracyCircle);
            }
            
            // Th√™m v√≤ng tr√≤n ƒë·ªô ch√≠nh x√°c (n·∫øu c√≥)
            if (accuracy) {
                accuracyCircle = L.circle([lat, lng], {
                    radius: accuracy,
                    color: '#3498db',
                    fillOpacity: 0.2,
                    weight: 1,
                    className: 'accuracy-circle'
                }).addTo(map);
            }
            
            // Th√™m control ph√≥ng to
            addMapControls(lat, lng);
        }

        function addMapControls(lat, lng) {
            // X√≥a controls c≈© n·∫øu c√≥
            const oldControls = document.querySelector('.map-controls');
            if (oldControls) oldControls.remove();
            
            // T·∫°o div ch·ª©a controls
            const controlsDiv = L.DomUtil.create('div', 'map-controls');
            
            // N√∫t ph√≥ng to
            const zoomBtn = L.DomUtil.create('button', 'map-control-btn', controlsDiv);
            zoomBtn.innerHTML = 'üîç Ph√≥ng to';
            zoomBtn.onclick = () => {
                map.setView([lat, lng], 16);
                marker.openPopup();
            };
            
            // N√∫t xem to√†n c·∫£nh
            const viewAllBtn = L.DomUtil.create('button', 'map-control-btn', controlsDiv);
            viewAllBtn.innerHTML = 'üåè To√†n c·∫£nh';
            viewAllBtn.onclick = () => {
                if (adminBoundary) {
                    map.fitBounds(adminBoundary.getBounds());
                } else {
                    map.setView([lat, lng], 12);
                }
            };
            
            // Th√™m v√†o b·∫£n ƒë·ªì
            map.getContainer().appendChild(controlsDiv);
        }

        async function getEnhancedAddressInfo(lat, lng) {
            try {
                // Th·ª≠ l·∫•y t·ª´ Nominatim API tr∆∞·ªõc
                const nominatimResult = await getNominatimAddress(lat, lng);
                
                // N·∫øu ·ªü ƒê·ªìng Th√°p v√† thi·∫øu th√¥ng tin ph∆∞·ªùng/x√£
                if ((nominatimResult.province === "T·ªânh ƒê·ªìng Th√°p" || nominatimResult.province === "ƒê·ªìng Th√°p") && !nominatimResult.ward) {
                    // Th·ª≠ l·∫•y t·ª´ Overpass API
                    const overpassResult = await getOverpassAddress(lat, lng);
                    if (overpassResult.ward) {
                        nominatimResult.ward = overpassResult.ward;
                    } else {
                        // Fallback cho khu v·ª±c n√¥ng th√¥n
                        nominatimResult.ward = "Khu v·ª±c n√¥ng th√¥n";
                        nominatimResult.ruralArea = true;
                    }
                }
                
                return nominatimResult;
            } catch (error) {
                console.error('L·ªói khi l·∫•y ƒë·ªãa ch·ªâ:', error);
                throw error;
            }
        }

        async function getNominatimAddress(lat, lng) {
            const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1&accept-language=vi`);
            
            if (!response.ok) {
                throw new Error('Kh√¥ng th·ªÉ l·∫•y th√¥ng tin ƒë·ªãa ch·ªâ t·ª´ Nominatim');
            }
            
            const data = await response.json();
            
            if (!data.address) {
                throw new Error('Kh√¥ng t√¨m th·∫•y th√¥ng tin ƒë·ªãa ch·ªâ cho v·ªã tr√≠ n√†y');
            }
            
            const addr = data.address;
            
            // X√°c ƒë·ªãnh c√°c c·∫•p h√†nh ch√≠nh
            return {
                country: addr.country,
                province: addr.state || addr.province,
                district: addr.city_district || addr.district || addr.municipality,
                ward: addr.suburb || addr.neighbourhood || addr.quarter || addr.residential,
                village: addr.village || addr.hamlet,
                road: addr.road,
                fullAddress: formatAddress(addr),
                osmData: data
            };
        }

        async function getOverpassAddress(lat, lng) {
            try {
                const radius = 1000; // 1km
                const query = `
                    [out:json];
                    (
                        node(around:${radius},${lat},${lng})["place"="village"];
                        node(around:${radius},${lat},${lng})["place"="hamlet"];
                        way(around:${radius},${lat},${lng})["place"="village"];
                        way(around:${radius},${lat},${lng})["place"="hamlet"];
                    );
                    out body;
                    >;
                    out skel qt;
                `;
                
                const response = await fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`);
                const data = await response.json();
                
                if (data.elements && data.elements.length > 0) {
                    // L·∫•y t√™n t·ª´ ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n
                    const firstElement = data.elements[0];
                    return {
                        ward: firstElement.tags.name || "Khu v·ª±c n√¥ng th√¥n"
                    };
                }
                
                return {};
            } catch (error) {
                console.error('L·ªói khi query Overpass:', error);
                return {};
            }
        }

        function formatAddress(addr) {
            const parts = [];
            
            if (addr.road) parts.push(`ƒê∆∞·ªùng ${addr.road}`);
            if (addr.hamlet) parts.push(`Th√¥n ${addr.hamlet}`);
            if (addr.village) parts.push(`X√£ ${addr.village}`);
            if (addr.neighbourhood) parts.push(`Khu ${addr.neighbourhood}`);
            if (addr.quarter) parts.push(`Khu ph·ªë ${addr.quarter}`);
            if (addr.suburb) parts.push(`Ph∆∞·ªùng ${addr.suburb}`);
            if (addr.city_district) parts.push(`Qu·∫≠n ${addr.city_district}`);
            if (addr.district) parts.push(`Huy·ªán ${addr.district}`);
            if (addr.town) parts.push(`Th·ªã tr·∫•n ${addr.town}`);
            if (addr.city) parts.push(`Th√†nh ph·ªë ${addr.city}`);
            if (addr.state) parts.push(addr.state);
            if (addr.country) parts.push(addr.country);
            
            return parts.join(', ');
        }

        function displayAddressInfo(address) {
            const resultDiv = document.getElementById('result-container');
            
            let html = `
                <div class="location-card ${address.ruralArea ? 'rural-area' : ''}">
                    <div class="location-title">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#2ecc71" stroke-width="2">
                            <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>
                        </svg>
                        Th√¥ng tin v·ªã tr√≠ c·ªßa b·∫°n
                    </div>
            `;
            
            // Hi·ªÉn th·ªã th√¥ng tin ph∆∞·ªùng/x√£
            if (address.ward) {
                html += `
                    <div class="address-detail">
                        <span class="detail-label">Ph∆∞·ªùng/X√£:</span>
                        <span>${address.ward}</span>
                    </div>
                `;
            }
            
            // Hi·ªÉn th·ªã qu·∫≠n/huy·ªán
            if (address.district) {
                html += `
                    <div class="address-detail">
                        <span class="detail-label">Qu·∫≠n/Huy·ªán:</span>
                        <span>${address.district}</span>
                    </div>
                `;
            }
            
            // Hi·ªÉn th·ªã t·ªânh/th√†nh ph·ªë
            if (address.province) {
                html += `
                    <div class="address-detail">
                        <span class="detail-label">T·ªânh/Th√†nh ph·ªë:</span>
                        <span>${address.province}</span>
                    </div>
                `;
            }
            
            // Hi·ªÉn th·ªã th√¥n/x√≥m (n·∫øu c√≥)
            if (address.village) {
                html += `
                    <div class="address-detail">
                        <span class="detail-label">Th√¥n/X√≥m:</span>
                        <span>${address.village}</span>
                    </div>
                `;
            }
            
            // Hi·ªÉn th·ªã ƒë∆∞·ªùng (n·∫øu c√≥)
            if (address.road) {
                html += `
                    <div class="address-detail">
                        <span class="detail-label">ƒê∆∞·ªùng:</span>
                        <span>${address.road}</span>
                    </div>
                `;
            }
            
            // Th√™m c·∫£nh b√°o cho khu v·ª±c n√¥ng th√¥n
            if (address.ruralArea) {
                html += `
                    <div class="warning">
                        <strong>L∆∞u √Ω:</strong> ƒê√¢y l√† khu v·ª±c n√¥ng th√¥n, th√¥ng tin ph∆∞·ªùng/x√£ c√≥ th·ªÉ kh√¥ng ch√≠nh x√°c do h·∫°n ch·∫ø d·ªØ li·ªáu.
                    </div>
                `;
            }
            
            // Th√™m th√¥ng tin t·ªça ƒë·ªô
            if (currentPosition) {
                const lat = currentPosition.coords.latitude.toFixed(6);
                const lng = currentPosition.coords.longitude.toFixed(6);
                html += `
                    <div class="address-detail">
                        <span class="detail-label">T·ªça ƒë·ªô:</span>
                        <span>${lat}, ${lng}</span>
                    </div>
                `;
            }
            
            html += `</div>`;
            
            resultDiv.innerHTML = html;
        }

        async function fetchAdministrativeBoundary(lat, lng, address) {
            // X√≥a ranh gi·ªõi c≈© n·∫øu c√≥
            if (adminBoundary) {
                map.removeLayer(adminBoundary);
                adminBoundary = null;
            }
            
            try {
                // Th·ª≠ l·∫•y ranh gi·ªõi ph∆∞·ªùng/x√£ tr∆∞·ªõc (admin_level=8)
                if (address.ward && address.ward !== "Khu v·ª±c n√¥ng th√¥n") {
                    const wardBoundary = await fetchOSMBoundary(lat, lng, 8);
                    if (wardBoundary) {
                        adminBoundary = L.geoJSON(wardBoundary, {
                            style: boundaryStyles.ward
                        }).addTo(map);
                        map.fitBounds(adminBoundary.getBounds());
                        return;
                    }
                }
                
                // Th·ª≠ l·∫•y ranh gi·ªõi qu·∫≠n/huy·ªán (admin_level=7)
                if (address.district) {
                    const districtBoundary = await fetchOSMBoundary(lat, lng, 7);
                    if (districtBoundary) {
                        adminBoundary = L.geoJSON(districtBoundary, {
                            style: boundaryStyles.district
                        }).addTo(map);
                        map.fitBounds(adminBoundary.getBounds());
                        return;
                    }
                }
                
                // Th·ª≠ l·∫•y ranh gi·ªõi t·ªânh (admin_level=4)
                if (address.province) {
                    const provinceBoundary = await fetchOSMBoundary(lat, lng, 4);
                    if (provinceBoundary) {
                        adminBoundary = L.geoJSON(provinceBoundary, {
                            style: boundaryStyles.province
                        }).addTo(map);
                        map.fitBounds(adminBoundary.getBounds());
                        return;
                    }
                }
                
                console.log('Kh√¥ng t√¨m th·∫•y ranh gi·ªõi h√†nh ch√≠nh ph√π h·ª£p');
                
            } catch (error) {
                console.error('L·ªói khi l·∫•y ranh gi·ªõi:', error);
            }
        }

        async function fetchOSMBoundary(lat, lng, adminLevel) {
            // ƒê√¢y l√† h√†m gi·∫£ l·∫≠p do Overpass API th·ª±c t·∫ø c·∫ßn query ph·ª©c t·∫°p
            // Trong th·ª±c t·∫ø, b·∫°n c·∫ßn tri·ªÉn khai query Overpass API ch√≠nh x√°c
            
            // T·∫°o ranh gi·ªõi gi·∫£ l·∫≠p cho demo
            return createDemoBoundary(lat, lng, adminLevel);
        }

        function createDemoBoundary(lat, lng, adminLevel) {
            // K√≠ch th∆∞·ªõc ranh gi·ªõi gi·∫£ l·∫≠p (t√πy thu·ªôc v√†o c·∫•p h√†nh ch√≠nh)
            const size = 0.02 * (5 - (adminLevel - 4)); // C·∫•p c√†ng cao, di·ªán t√≠ch c√†ng l·ªõn
            
            return {
                "type": "FeatureCollection",
                "features": [{
                    "type": "Feature",
                    "properties": {
                        "admin_level": adminLevel,
                        "name": "Ran gi·ªõi demo"
                    },
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": [[
                            [lng - size, lat - size/2],
                            [lng + size, lat - size/2],
                            [lng + size, lat + size/2],
                            [lng - size, lat + size/2],
                            [lng - size, lat - size/2]
                        ]]
                    }
                }]
            };
        }

        function showResultMessage(message, type = 'info') {
            const resultDiv = document.getElementById('result-container');
            
            let icon, color;
            switch(type) {
                case 'error':
                    icon = '‚ùå';
                    color = '#e74c3c';
                    break;
                case 'warning':
                    icon = '‚ö†Ô∏è';
                    color = '#f39c12';
                    break;
                default:
                    icon = '‚ÑπÔ∏è';
                    color = '#3498db';
            }
            
            resultDiv.innerHTML = `
                <div class="location-card">
                    <div class="location-title" style="color: ${color}">
                        ${icon} ${message}
                    </div>
                </div>
            `;
        }

        // Th√™m ch√∫ th√≠ch cho b·∫£n ƒë·ªì
        function addLegend() {
            const legend = L.control({ position: 'bottomright' });
            
            legend.onAdd = function(map) {
                const div = L.DomUtil.create('div', 'legend');
                div.innerHTML = `
                    <h4>Ch√∫ th√≠ch</h4>
                    <div><i style="background: #e74c3c"></i> Ranh gi·ªõi ph∆∞·ªùng/x√£</div>
                    <div><i style="background: #9b59b6"></i> Ranh gi·ªõi qu·∫≠n/huy·ªán</div>
                    <div><i style="background: #3498db"></i> Ranh gi·ªõi t·ªânh/th√†nh</div>
                    <div><i style="background: #2ecc71"></i> V·ªã tr√≠ c·ªßa b·∫°n</div>
                    <div><i style="background: #3498db; opacity: 0.2; border: 1px solid #3498db"></i> ƒê·ªô ch√≠nh x√°c</div>
                `;
                return div;
            };
            
            legend.addTo(map);
        }

        // Kh·ªüi t·∫°o ch√∫ th√≠ch khi t·∫£i trang
        addLegend();
    </script>
</body>
</html>